\documentclass{beamer}[10]


%
% macro
%

\input{partecstyle.tex}

\title{Scaling MySQL with Python and Fabric}
\subtitle{EuroPython 2015, $22^{th}$ July - Bilbao}
\author{Roberto Polli - \href{mailto:roberto.polli@par-tec.it}{roberto.polli@par-tec.it}}
\date{21-27 July 2015}
\institute{Par-Tec Spa - Rome Operation Unit\\
    P.zza S. Benedetto da Norcia, 33\\
    00040, Pomezia (RM) - www.par-tec.it}

%
%
\begin{document}

%% cover
\frame{\titlepage 
\vspace{-0.5cm}
}


%% agenda
\iffalse
\frame{\frametitle{Agenda}
\tiny
\tableofcontents%[pausesection]
}
\fi

%% Starting doc
\section{Intro}
\frame{ \frametitle{Who? What? Why?}
\begin{itemize}

\item Manage, replicate, scale MySQL databases with python
\\

\item Roberto Polli - Solutions Architect @ par-tec.it. Loves writing in C,
Java and Python. Red Hat Certified Engineer and Virtualization
Administrator.
\\
\\
\item Par-Tec â€“ Proud sponsor of this talk ;) Contributes to various FLOSS. \\
Provides expertise in IT Infrastructure \& Services and \\ Business Intelligence
solutions + Vertical Applications for the financial market.

\end{itemize}
}

\begin{pyframe}{Agenda}
\begin{itemize}
\item Prepare setup
\item MySQL architecture
\item Getting informations
\item Comparing databases
\item Replication 2.0 aka GTID
\item Fabric: scaling & sharding for the masses
%\item modules: \pymodule{scipy, matplotlib}
\end{itemize}
\end{pyframe}

\begin{pyframe}{Setup}
\begin{minted}
git clone https://github.com/ioggstream/mysql-community
pip install -r requirements.txt
sudo apt-get install lxc-docker ||
yum -y install docker
docker pull ioggstream/mysql-community

\end{minted}
\end{pyframe}


\section{MySQL 101}
\begin{pyframe}{MySQL Architecture}
\begin{itemize}
\item MySQL is not only SQL
% Query parser vs engine store
\item Architecture of a database
% query parser, cache, transaction log, MVCC
% http://www.oracle.com/technetwork/articles/javase/figure2-large-145676.jpg
\item MVCC
\item Replication
\item Consistency is here to stay
%
\end{itemize}
\end{pyframe}


\begin{pyframe}{MySQL Architecture}
\includegraphics[height=5.5cm]{mysql-architecture.pdf}
{\large
\begin{center}
It's a lot of stuff
\end{center}
}
\end{pyframe}


\begin{pyframe}{MySQL Architecture}
% Map in the figure every task
We should manage and monitor
\begin{itemize}
\item Database size: Tables, Indexes, Binary Logs
\item Replication inconsistencies
\item Failover
\end{itemize}
Can all of this be simpler?
\end{pyframe}


\begin{pyframe}{Make it simple}
Yes!
\begin{minted}{bash}
# wget https://dev.mysql.com/get/Downloads/MySQLGUITools/mysql-utilities-1.6.1.tar.gz
# tar xf mysql-utilities-1.6.1.tar.gz
# python setup.py install
\end{minted}{bash}
or
\begin{minted}{bash}
# yum -y install https://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
# yum -y install mysql-utilites
\end{minted}{bash}
\end{pyframe}


\begin{pyframe}{Preparing your setup}
Avoid typing credentials!
\begin{minted}{bash}
# cat /etc/my.cnf
# This is the client stanza of my.cnf
[mysql]
user=fabric
password=fabric
\end{minted}{bash}
and
\begin{minted}{bash}

\end{minted}{bash}
\end{pyframe}




\begin{pyframe}{Single Entrypoint: mysqluc}
Start with \code{mysqluc}

\begin{itemize}
\item An entrypoint for all utilities
\item Contextual help
\item TAB completion
\end{itemize}
\end{pyframe}


\iffalse
\begin{pyframe}{Managing binlog}
Managing binlog with \code{mysqlbinlogmove} and
\code{mysqlbinlogpurge}
\end{pyframe}
\fi


\begin{pyframe}{Disk usage}
A single command to show all disk usage infos (excluded system logs)

\begin{minted}{bash}
$ mysqldiskusage --server=root:secret@s-1.docker --all |grep -- =
Total database disk usage = 7601892 bytes or 7.25 MB
Current binary log file = s-1-bin.000009
Total size of binary logs = 231 bytes
\end{minted}{bash}

\end{pyframe}

%
% Exporting and Importing
%
\begin{pyframe}{Export - I}
You can forget mysqldump and use the following
command for complete and consistent backup.
\begin{minted}{bash}
$ mysqldbexport > data.sql \
--server=root:root@localhost:13001
--all
\end{minted}{bash}
% --export=master --rpl=master --rpl-user=rpl:rpl

Attention: to backup big databases, use InnoDB engine
and an InnoDB backup tool!
\end{pyframe}


\begin{pyframe}{Import - I}
Then import the dump with
\begin{minted}{bash}
$mysqldiff \
    --server1=root:root@master:3306 \
    --server2=root:root@slave:3306 \
    sakila:sakila --changes-for=server2
\end{minted}
To provision a new slave we'll use a similar
procedure with some variants.
\end{pyframe}






%
% Comparing
%
\begin{pyframe}{Comparing databases - I}
To compare databases, use
\begin{minted}{bash}
#mysqldbcompare \
    --server1=root:root@master:3306 \
    --server2=root:root@slave:3306 \
    sakila -a --difftype=SQL \
    --show-reverse --quiet
\end{minted}{bash}
\end{pyframe}


\begin{pyframe}{Comparing databases - II}
We can create the statemets to fix the differences!
\begin{minted}{bash}
#mysqldiff \
    --server1=root:root@master:3306 \
    --server2=root:root@slave:3306 \
    sakila:sakila --changes-for=server2
\end{minted}{bash}
\end{pyframe}


%
% replication
%
\begin{pyframe}{Replication 2.0}
MySQL 5.6+ replication is based on Global Transaction ID
\begin{itemize}
\item Every server has a unique UUID \\
\code{3E11FA47-71CA-11E1-9E33-C80AA9429562}

\item This makes every TransactionID a Global one
\code{3E11FA47-71CA-11E1-9E33-C80AA9429562:32}
\end{itemize}
GTIDs avoid loops in replication!
\end{pyframe}


\begin{pyframe}{Configuring replication}
\begin{itemize}
\item In MySQL replication is configured on the slave only.
\item The slave connects to the master with a provisioned
 user and gets its changelog (binlog).
\end{itemize}
%% IMAGE
If binlog had been purged, you need to import the
master database first!
\end{pyframe}


\begin{pyframe}{Configuring replication}
mysqlreplicate takes care of
\begin{itemize}
\item provisioning the replica user on the master;
\item get a suitable GTID;
\item configure the slave to point to the master.
\end{itemize}
\begin{minted}
mysqlreplicate \
 --master=root:pass@master \
 --slave=root:pass@slave \
 --rpl-user=repl:rpass \
 -b

# master on 192.168.1.1: ... connected.
# slave on 192.168.1.2: ... connected.
# Checking for binary logging on master...
# Setting up replication...
# ...done.
\end{minted}
Obviously
\end{pyframe}

\begin{pyframe}{Configuring replication -II}
You can provision a new slave creating a suitable dump
with mysqldbexport. Just:
\begin{itemize}
\item check that replica user is provisioned on the master;
\item create a custom dump.sql;
\item add --export=master;
\end{itemize}
\begin{minted}
cat > data.sql <<EOF
-- ignore previous changelogs
-- and trust the backup only
STOP SLAVE;
RESET MASTER;
COMMIT;

EOF

mysqldbexport >> data.sql \
 --server=root:pass@master \
 --rpl-user=repl:rpass \
 --export=master \
 --rpl=master \
 --all

mysqldbimport --server=root:root@slave \
 data.sql
\end{minted}
\end{pyframe}



\begin{pyframe}{Failover - I}
mysqlfailover, requires report-host
\end{pyframe}


\begin{pyframe}{Failover - II}
example failover
\end{pyframe}

\begin{pyframe}{Fabric - I}
\includegraphics[height=6.6cm,width=12cm]{monochromo_cpu_wait_buff.pdf}
\end{pyframe}

\begin{pyframe}{Fabric - II}
\end{pyframe}


\begin{pyframe}{Wrap Up}
\begin{itemize}
\item Use MySQL Utilities
\item Enjoy replicatioon
\item Don't reingest failed master
\item Try Fabric
\end{itemize}
\end{pyframe}


\iffalse
\begin{pyframe}{mysqlbackup \-\-what}
To make a consistent backup you need to know
 how your data are stored (engine, ...).
 Are you sure your backup is:
\begin{itemize}
\item consistent?
\item usable?
\item without side effect?
\end{itemize}
Curious? Attend `MySQL for Pythonistas' on FIXME
\end{pyframe}
\fi


\begin{pyframe}{That's all folks!}
\begin{center}
Thank you for the attention! \\\\
\insertauthor
\end{center}
\end{pyframe}


\end{document}
