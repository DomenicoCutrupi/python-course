\section{Parsing: 60'}



\begin{frame}[fragile]{Parsing is hard...}
\begin{verse}
"In 2000-2010, System Administrators spent $24\%$ of their life parsing files."$^{*}$\\
\hfill Independent analysis by The GASP Society
\end{verse}
\end{frame}


\begin{frame}[fragile]{...use a strategy!}
\begin{enumerate}
\item Collect parsing samples
\item Play in ipython
\item Write tests
\item Write parser
\end{enumerate}
\end{frame}



\begin{frame}[fragile]{Parsing postfix logs}
\begin{pythoncode}
# Before writing the parser, collect samples of
#  the interesting lines. For now just 
from examples import mail_sent, mail_delivered

# have a look 
print (log_mail_sent, log_mail_delivered)

# and write a simple 
def test_for_sent_mail():
    hour, host, destination = parse_line(mail_sent)
    assert hour == '08:30:55'
    assert host = 'test-fe1'
    assert destination = 'antani2@example.it'

\end{pythoncode}
\end{frame}


\begin{frame}[fragile]{Parsing lines: split, zip}
\begin{pythoncode}
# Start using basic strings in ipython
mail_sent.split()

# Then tie them with zip/zip() 
fields, counting  = _, zip(range(20), _)

# We just care for the first 7 values
fields = fields[:7]

# and we can use _ to discard values too
_, _, hour, host, _, _, dest = fields
# or pick fields singularly
hour, host, dest = fields[3], fields[4], fields[7]

\end{pythoncode}
\end{frame}


\begin{frame}[fragile]{Parse: Exercise I }
In \emph{another} window
\begin{itemize}
\item edit 03\_ parsing\_ test.py
\item complete the \code{parse\_line(line)} function
\begin{pythoncode}
def parse_line(line):
    """Write your function and test it
        with test_sent()
    """
    raise NotImplementedError
\end{pythoncode}
\end{itemize}
\emph{\%paste} your solution's code in iPython and run manually
the test functions
\end{frame}



\subsection{Regular Expressions}

\begin{frame}[fragile]{Python Regexp}
\begin{pythoncode}
# Python supports regular expressions via
import re

# We start showing a grep-reloaded function
def grep(expr, fpath):
    one = re.compile(expr) 
    # ...has two lookup methods...
    assert ( one.match    # which searches from ^
         and one.search ) # that searches anywhere
    with open(fpath) as fp:
        return [x for x in fp if one.search(x)]

\end{pythoncode}
\end{frame}

\begin{frame}[fragile]{Splitting with re.split}
\begin{pythoncode}
from re import split # is a very nice function

# Let's gather some ping stats

if sys.platform.startswith('linux'):
    cmd = "ping -c10 -w10 www.google.it"
elif sys.platform.startswith('win'):
    cmd = "ping -n10 www.google.it"    
else: # 'darwin' in sys.platform?
    raise ValueError("Are you really using OSX?")
    
ping_output = [ split("[ =", x) for x in ping_output]

\end{pythoncode}
\end{frame}


\begin{frame}[fragile]{Splitting with re.findall}
\begin{pythoncode}
from re import findall # can be misused too ;)

# eg. for adding the ":" to a 
mac_address = "00""24""e8""b4""33""20"

# ...using this 
re_hex = '[0-9a-fA-F]'
mac = ':'.join(findall(re_hex, mac_address))
print("The mac address is ", mac_address)

\end{pythoncode}
\emph{
Actually this does a bit of validation, 
 requiring all chars to be in the 0-F range}
\end{frame}




\begin{frame}[fragile]{Benchmarking I}
\begin{itemize}
\item Parsing big files may need some benchmarks.
iPython \emph{\%timeit} magic is a good starting point.
\begin{pythoncode}

test_all_regexps = ("..", "[a-f0-9]{2}")
for re_s in test_all_regexps:
    %timeit ':'.join(findall(re_s, mac_address))

\end{pythoncode}
\item We can even compare compiled and inline regexp
\begin{pythoncode}

test_all_regexps = ("..", "[a-f0-9]{2}")
for re_s in test_all_regexps:
    re_c = re.compile(re_s)
    %timeit ':'.join(re_c.findall(mac_address))

\end{pythoncode}
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Benchmarking II}
Or find other methods: 
\begin{itemize}
\item complex...
\begin{pythoncode}
from re import sub as sed
%timeit sed(r'(..)', r'\1:', mac_address)
\end{pythoncode}
\item ...or simple
\begin{pythoncode}
\%timeit ':'.join([ mac_address[i:i+2] 
    for i in xrange(0,12,2)])
\end{pythoncode}
\end{itemize}
\end{frame}

%

\begin{frame}[fragile]{Real World Example}
\begin{pythoncode}
# Generate a VSAN configuration using linux 
#  FC information from /sys filesystem
fc_id_path = "/sys/class/fc_host/host*/port_name"
for x in glob.glob(fc_id_path):
    # ...we boldly skip an explicit close()
    pwwn = open(x).read()  # 0x500143802427e66c
    pwwn = pwwn[2:]
    # ...and even use the slower but readable
    pwwn = re.findall(r'..', pwwn)
    print("member pwwn ", ':'.join(pwwn))

\end{pythoncode}
\end{frame}

%%
\begin{frame}[fragile]{Parsing logs: a simple solution}
\begin{pythoncode}
def parse_line(line):
    import re
    # using _ we improve readability
    _, _, hour, host, _, _, dest = line.split()[:7]
    try:
        # and if dest isn't what we expect...
        dest = re.split(r'[<>]',dest)[1]
    except IndexError:
        # ...we set it to None
        dest = None
    return (hour, host, dest)
\end{pythoncode}
\end{frame}
