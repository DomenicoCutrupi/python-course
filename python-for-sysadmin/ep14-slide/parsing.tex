\section{Parsing: 60'}

\begin{frame}[fragile]{Parsing: Goal}
\begin{itemize}
\item Plan a parsing strategy
\item Use basic regular expressions: match, search, sub
\item Benchmarking a parser
\item Running nosetests
\item Write a simple parser
\end{itemize}
modules: \pymodules{re, nose, \%timeit}
\end{frame}


\begin{frame}[fragile]{Parsing is hard...}
\begin{verse}
"System Administrators spent $24\%$ of
 their work-life parsing files."$^{*}$\\
\hfill *Independent analysis by The GASP Society ;)
\end{verse}
\end{frame}


\begin{frame}[fragile]{...use a strategy!}
\begin{enumerate}
\Large
\item Collect parsing samples
\item Play in ipython
\item Write tests, then the parser
\item \emph{Eventually} benchmark
\end{enumerate}
\end{frame}



\begin{frame}[fragile]{Parsing postfix logs}
\begin{pythoncode}
# Before writing the parser, collect samples of
#  the interesting lines. For now just 
from examples import mail_sent, mail_delivered

# and write a simple 
def test_for_sent_mail():
    hour, host, destination = parse_line(mail_sent)
    assert hour == '08:30:55'
    assert host == 'test-fe1'
    assert destination = 'antani2@example.it'

\end{pythoncode}
\end{frame}


\begin{frame}[fragile]{Parsing lines: split, zip}
\begin{pythoncode}
mail_sent.split()   # Start using basic strings in ipython

# Then tie them with zip/zip() 
fields, counting  = _, zip(range(20), _)

fields = fields[:7] # We just care for the first 7 values

# and we can use _ to discard values too
_, _, hour, host, _, _, dest = fields
# or pick fields singularly
hour, host, dest = fields[3], fields[4], fields[7]

\end{pythoncode}
\end{frame}


\begin{frame}[fragile]{Parse: Exercise I }
In \emph{another} window
\begin{itemize}
\item edit 03\_ parsing\_ test.py
\item complete the \code{parse\_line(line)} function
\begin{pythoncode}
def parse_line(line):
    """Write your function and test it
        with test_sent()"""
    raise NotImplementedError
\end{pythoncode}
\end{itemize}
\pyver{\\\%paste} your solution's code in iPython and run manually
the test functions
\end{frame}



\subsection{Regular Expressions}

\begin{frame}[fragile]{Python Regexp}
\begin{pythoncode*}{escapeinside=||}
# Python supports regular expressions via
import re

# We start showing a grep-reloaded function
def grep(expr, fpath):
    one = re.compile(expr) 
    # ...has two lookup methods...
    assert ( one.|\emph{match}|     # which searches from ^ the beginning
         and one.|\pyver{search}| ) # that searches $\pyver{anywhere}$
    with open(fpath) as fp:
        return [x for x in fp if one.|\emph{search}|(x)]

\end{pythoncode*}
\end{frame}

\begin{frame}[fragile]{Splitting with re.split}
\begin{pythoncode}
from re import split # is a very nice function

# Let's gather some ping stats
if sys.platform.startswith('linux'):
    cmd = "ping -c10 -w10 www.google.it"
elif sys.platform.startswith('win'):
    cmd = "ping -n10 www.google.it"    
else: # 'darwin' in sys.platform?
    raise ValueError("Are you really using OSX?")
    
ping_output = [ split("[ =", x) for x in sh(cmd)]

\end{pythoncode}
\end{frame}


\begin{frame}[fragile]{Splitting with re.findall}
\begin{pythoncode}
from re import findall # can be misused too ;)

# eg. for adding the ":" to a 
mac_address = "00""24""e8""b4""33""20"

# ...using this 
re_hex = '[0-9a-fA-F]'
mac = ':'.join(findall(re_hex, mac_address))
print("The mac address is ", mac)

\end{pythoncode}
\emph{
Actually this does a bit of validation, 
 requiring all chars to be in the 0-F range}
\end{frame}




\begin{frame}[fragile]{Benchmarking in iPython I}
\begin{itemize}
\item Parsing big files needs benchmarks.
iPython \emph{\%timeit} magic is a good starting point.
\begin{pythoncode*}{escapeinside=||}

test_all_regexps = ("..", "[a-f0-9]{2}")
for re_s in test_all_regexps:
    |\pyver{%timeit}| ':'.join(|\pyfunction{findall}|(re_s, mac_address))

\end{pythoncode*}
\item We can even compare compiled and inline regexp
\begin{pythoncode*}{escapeinside=||}

test_all_regexps = ("..", "[a-f0-9]{2}")
for re_s in test_all_regexps:
    re_c = re.|\pyfunction{compile}|(re_s)
    |\pyver{%timeit}| ':'.join(re_c.|\pyfunction{findall}|(mac_address))

\end{pythoncode*}
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Benchmarking in iPython II}
Or find other methods: 
\begin{itemize}
\item complex...
\begin{pythoncode}
from re import sub as sed
%timeit sed(r'(..)', r'\1:', mac_address)
\end{pythoncode}
\item ...or simple
\begin{pythoncode}
%timeit ':'.join([ mac_address[i:i+2] for i in range(0,12,2)])
\end{pythoncode}
\item Outside iPython check the \pymodule{timeit} module
\end{itemize}
\end{frame}

%

\begin{frame}[fragile]{Parsing: a real world Example}
\begin{pythoncode}
# Generate a VSAN configuration using linux 
#  FC information from /sys filesystem
fc_id_path = "/sys/class/fc_host/host*/port_name"
for x in glob.glob(fc_id_path):
    # ...we boldly skip an explicit close()
    pwwn = open(x).read()  # 0x500143802427e66c
    pwwn = pwwn[2:]
    # ...and even use the slower but readable
    pwwn = re.findall(r'..', pwwn)
    print("member pwwn ", ':'.join(pwwn))

\end{pythoncode}
\end{frame}

%%
\begin{frame}[fragile]{Parsing logs: a simple solution}
\begin{pythoncode}
def parse_line(line):
    import re
    # using _ we improve readability
    _, _, hour, host, _, _, dest = line.split()[:7]
    try:
        # and if dest isn't what we expect...
        dest = re.split(r'[<>]',dest)[1]
    except IndexError:
        # ...we set it to None
        dest = None
    return (hour, host, dest)
\end{pythoncode}
\end{frame}
