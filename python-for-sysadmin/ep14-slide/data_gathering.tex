\section{Data Gathering: 20'}
%
% NOTE: minted allows mathescape everywhere now;)
%


\begin{frame}{Data Gathering: Goal}
    Gathering System Data with multiplatform
     and platform-dependent tools.
\begin{itemize}
\item Get infos from files, /proc and /sys 
\item Run and capture command output
\item Use psutil to get IO, CPU and memory data
\item Parse files with a strategy
\end{itemize}
modules: \pymodule{psutil, subprocess, os}
\end{frame}


\begin{frame}[fragile]{Data Gathering: grep}
\begin{pythoncode}
def grep(needle, fpath):
    """is a minimal grep implementation

       goal: open() is iterable and doesn't
             need splitlines()
       goal: comprehension can filter iterables
    """
    return [x for x in open(fpath) if needle in x]
    
# Do we have "localhost" in our "/etc/hosts"?
grep("localhost", "/etc/hosts")
\end{pythoncode}
\end{frame}

\subsection{module: psutil}
\begin{frame}[fragile]{Data Gathering: psutil}
\begin{pythoncode}
# The psutil module is very nice!
import psutil

# Works on Windows, Linux and MacOS
psutil.cpu_percent()

# And its output is easy to manage
psutil.disk_io_counters()

\end{pythoncode}
Exercise: Which other information does psutil provide?
\end{frame}


\begin{frame}[fragile]{Data Gathering: Exercises}
Write a vmstat-like function printing every second:
\begin{itemize}
\item cpu usage \% ;
\item bytes read;
\item bytes written;
\item Hint: use psutil, time.sleep(1)
\end{itemize}
\end{frame}

\subsection{module: subprocess}
\begin{frame}[fragile]{Data Gathering: subprocess}
\begin{pythoncode}
# While 
from os import system

# is a shortcut to run programs using a shell
ret = system("ping -w1 -c1 www.google.com")
assert ret == 0, "Can't ping google"

# The check_output function returns the command stdout
from subprocess import check_output

out = check_output("ping -w1 -c1 www.google.com")

print(ret, out)
\end{pythoncode}
\end{frame}

\begin{frame}[fragile]{Data Gathering: subprocess, sys}
\begin{pythoncode*}{escapeinside=||}
def sh(cmd, timeout=0, shell=False):
  """"Returns the output of a given command using... """
  from subprocess import |\emph{check_output}| # ...and tests...
  from sys import version_info as |\emph{python_version}|
  if python_version < (3, 3): # ..before using...
    if |\emph{timeout}|:
      raise ValueError("Timeout not supported until v3.3")
    output = check_output(cmd.split(), shell=shell)
  else:
    output = check_output(cmd.split(), shell=shell, \
                          timeout=timeout)
  return output.splitlines()
    
\end{pythoncode*}
\end{frame}

\begin{frame}[fragile]{Data Gathering: Exercises}
Write a simple pgrep-like function for your OS which:
\begin{itemize}
\item takes one parameter: `program`;
\item return a list of processes executing `program`;
\item Hint: use \pymodule{subprocess, os}, and list-comprehension
\end{itemize}
\end{frame}


\subsection{The /proc filesystem}
\begin{frame}[fragile]{Data Gathering: Parsing /proc I}
\begin{pythoncode*}{escapeinside=||}

def linux_threads(pid):
  """The Linux /proc filesystem is a cool place to get infos."""
  import glob # emulates shell expansion of * and ?
  path = "/proc/{}/task/*/status".format(pid)
  
  # Pick a set of fields to gather...
  t_info = ('Pid', 'Tgid', 'voluntary') # a tuple
  for t in glob.glob(path):
    # ...and use comprehension to get interesting data.
    t_data = [x for x in open(t) 
        if x.|\pyver{startswith}|(t_info)] #  accepts tuples!
    print(t_data)
\end{pythoncode*}
\end{frame}



\begin{frame}[fragile]{Data Gathering: Parsing /proc II}
\begin{pythoncode*}{escapeinside=||}
# On Linux, /proc/diskstats is the source of I/O infos
disk_l = grep("sda", "/proc/diskstats")

# To gather that data we put the headers in a multi-line string
head = ('major minor device'
        ' reads reads_merged reads_sectors reads_ms'
        ' writes writes_merged writes_sectors writes_ms'
        ' io_in_progress io_ms_spent io_ms_weight').|\pyver{split()}|
        
disk_info = disk_l[0].split() # Take the 1st entry, split the datas ...
zip(head, disk_info)          # ...and tie them with the headers
list(_) # On py3 you need to iterate the generator!
\end{pythoncode*}
\end{frame}

\begin{frame}[fragile]{Data Gathering: Parsing /proc III}
\begin{pythoncode}
# Or create a reusable commodity structure with
from collections import namedtuple
DiskStats = namedtuple('DiskStat', info, verbose=True)

dstat = DiskStats(*disk_info)
dstat.device, dstat.writes_ms

# Homework: check further features with
help(collections) 
\end{pythoncode}
\end{frame}


%%
\iffalse
\begin{frame}[fragile]{Data Gathering: subprocess}
\begin{pythoncode}
# foo
\end{pythoncode}
\end{frame}

\fi
