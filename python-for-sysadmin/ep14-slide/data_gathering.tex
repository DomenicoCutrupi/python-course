\section{Data Gathering: 20'}
%
% NOTE: minted allows mathescape in #comments ;)
%       not outside
%


\begin{frame}{Data Gathering: Goal}
    Gathering System Data with multiplatform
     and platform-dependent tools.
\begin{itemize}
\item Get infos from files, /proc and /sys with a grep function
\item Run and capture command output
\item Use psutil to get IO, CPU and memory data
\item Parse files with a strategy
\item module: \emph{psutil, subprocess, os}
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Data Gathering: grep}
\begin{pythoncode}
def grep(needle, fpath):
    """is a minimal grep implementation

       goal: open() is iterable and doesn't
             need splitlines()
       goal: comprehension can filter iterables
    """
    return [x for x in open(fpath) if needle in x]
    
# Do we have "localhost" in our "/etc/hosts"?
grep("localhost", "/etc/hosts")
\end{pythoncode}
\end{frame}

\subsection{module: psutil}
\begin{frame}[fragile]{Data Gathering: psutil}
\begin{pythoncode}
# The psutil module is very nice!
import psutil

# Works on Windows, Linux and MacOS
psutil.cpu_percent()

# And its output is easy to manage
psutil.disk_io_counters()

# Exercise: Which other information can we get with psutil?
\end{pythoncode}
\end{frame}


\begin{frame}[fragile]{Data Gathering: Exercises}
Write a vmstat-like function printing every second:
\begin{itemize}
\item cpu usage \% ;
\item bytes read;
\item bytes written;
\item Hint: use psutil, time.sleep(1)
\end{itemize}
\end{frame}

\subsection{module: subprocess}
\begin{frame}[fragile]{Data Gathering: subprocess}
\begin{pythoncode}
# While 
from os import system

# is a shortcut to run programs using a shell
ret = system("ping -w1 -c1 www.google.com")
assert ret == 0, "Can't ping google"

# The check_output function returns the command stdout
from subprocess import check_output

out = check_output("ping -w1 -c1 www.google.com")

print(ret, out)
\end{pythoncode}
\end{frame}

\begin{frame}[fragile]{Data Gathering: subprocess, sys}
\begin{pythoncode}
def sh(cmd, timeout=0, shell=False):
    """"Returns the output of a given command using... """
    from subprocess import check_output
    # ...and checks...
    from sys import version_info as python_version}
    if python_version < (3, 3):
        # ..before using...
        if timeout:
            raise ValueError("Timeout not supported until Python 3.3")
        output = check_output(cmd.split(), shell=shell)
    else:
        output = check_output(cmd.split(), shell=shell, timeout=timeout)
    return output.splitlines()
    
\end{pythoncode}
\end{frame}

\begin{frame}[fragile]{Data Gathering: Exercises}
Write a simple pgrep-like function for your OS which:
\begin{itemize}
\item takes one parameter: `program`;
\item return a list of processes executing `program`;
\item Hint: use subprocess, os, and list-comprehension
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Data Gathering: Parsing /proc I}
\begin{pythoncode}

def linux_threads(pid):
    """The linux /proc filesystem is a cool place 
        to get infos."""
    # $\emph{glob}$ emulates shell expansion of * and ?
    import glob
    path = "/proc/{}/task/*/status".format(pid)
    
    # Pick a set of fields to gather
    t_info = ('Pid', 'Tgid', 'voluntary')  # this is a tuple!
    for t in glob.glob(path):
        # And use comprehension to get interesting data
        t_info = [x for x in open(t) if x.startswith(t_info)]
        print(t_info)
\end{pythoncode}
\end{frame}



\begin{frame}[fragile]{Data Gathering: Parsing /proc II}
%% NOTE: avoid inserting print() statements in the slides. Students must do their inspection and check returned values
\begin{pythoncode}
# Linux speaks via the /proc filesystem
#  and /proc/diskstats is the source of I/O infos
disk_l = grep("sda", "/proc/diskstats")
print(disk_l)

# To gather that data we define a headers using a multi-line string
info = ('major minor device'
        ' reads reads_merged reads_sectors reads_ms'
        ' writes writes_merged writes_sectors writes_ms'
        ' io_in_progress io_ms_spent io_ms_weight').split()

# Then just take the 1st entry, split the data ...
disk_info = disk_l[0].split()
zip(info, disk_info)    # ...and tie them with the info

# Or create a reusable commodity structure
from collections import namedtuple
DiskStats=namedtuple('DiskStat', info)
dstat = DiskStats(*disk_info)
dstat.device, dstat.writes_ms
\end{pythoncode}
\end{frame}



%%
\begin{frame}[fragile]{Data Gathering: subprocess}
\begin{pythoncode}
# foo
\end{pythoncode}
\end{frame}

